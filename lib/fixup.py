# Copyright 2018 Timothy Baldwin
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import datetime
import repository

def use_original_refs():
    # Use refs/original/ in preference
    for r, c in list(repo.refs.items()):
        if r.startswith("refs/original/"):
            repo.refs["refs/" + r[14:]] = c    # Copy refs/original/X to X
            del repo.refs[r]                   # Delete refs/original/X so that it is not overwritten on save.

def remove_unneeded_branch_and_tag_commits():
    # Construct dict mapping the content of every commit
    # on the master branch to the commit itself
    trees = dict()
    for c in repo.refs["refs/heads/master"]:
        trees[c.tree_id] = c

    for c in repo.commits.values():
        if c.is_tag or c.is_branch:
            if len(c.parents) > 0 and c.tree_id == c.parents[0].tree_id:
                # Synthetic commit matches its parent, so can be replaced by it.
                c.replacement = c.parents[0]
            else:
                p = trees.get(c.tree_id)
                if p is not None:
                    # This synthetic is lost and redundant, replace
                    c.replacement = p

def tidy_default_branch_copies(remove_default):
    for c in repo.commits.values():
        if c.message.startswith("This commit was generated by cvs2svn to compensate for changes in "):
            p = c.parents[-1]
            if remove_default and c.tree_id == p.tree_id:
                # Synthetic merge into default branch is redundant. replace it with the merged in branch.
                c.replacement = p
            c.message = "Copy: " + p.message + "\n\nSynthetic merge due to changes in non-trunk default branch"

def get_ref(r, i=0):
    c = repo.refs.get("refs/heads/" + r)
    if c is None:
        c = repo.refs["refs/tags/" + r]
    while i > 0:
        i -= 1
        c = c.parents[0]
    return c

__merge_count = 0

def merge(c, p, i=0):
    global __merge_count
    c = get_ref(c, i)
    c.parents.append(get_ref(p))
    __merge_count += 1
    repo.refs["refs/merge/" + str(__merge_count)] = c

def reparent_tag(c, p, i):
    c2 = get_ref(c)
    p2 = get_ref(p, i)
    if not c2.is_tag:
        raise RuntimeError(c + " is not a tag commit")
    if p2.is_tag:
        raise RuntimeError(p + " is a tag commit")
    c2.parents = [p2]

def raise_tag(c):
    c2 = get_ref(c)
    if not c2.is_tag:
       raise RuntimeError(c + " is not a tag commit")
    c2.replacement = c2.parents[0]

def verify_ancestry(c1, a1):
    try:
        c = get_ref(c1)
        a = get_ref(a1)
    except KeyError:
        return
    while c != a:
        if len(c.parents) < 1:
            print("WARNING: In " + repo_name + " " + c1 + " is not a decendant of " + a1)
            return
        c = c.parents[0]

def have_branch():
    for c in repo.commits.values():
        c.used = False
    for c in repo.commits.values():
        for p in c.parents:
            if p.used:
                return True
            p.used = True
    return False
